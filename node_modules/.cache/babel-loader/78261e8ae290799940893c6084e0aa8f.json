{"ast":null,"code":"(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['moment-timezone'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('moment-timezone'), require('child_process'));\n  } else {\n    root.Cron = factory(root.moment);\n  }\n})(this, function (moment, childProcess) {\n  var exports = {};\n  var timeUnits = ['second', 'minute', 'hour', 'dayOfMonth', 'month', 'dayOfWeek'];\n  var spawn = childProcess && childProcess.spawn;\n\n  function CronTime(source, zone, utcOffset) {\n    this.source = source;\n\n    if (zone) {\n      if (moment.tz.names().indexOf(zone) === -1) {\n        throw new Error('Invalid timezone.');\n      }\n\n      this.zone = zone;\n    }\n\n    if (typeof utcOffset !== 'undefined') this.utcOffset = utcOffset;\n    var that = this;\n    timeUnits.map(function (timeUnit) {\n      that[timeUnit] = {};\n    });\n\n    if (this.source instanceof Date || this.source._isAMomentObject) {\n      this.source = moment(this.source);\n      this.realDate = true;\n    } else {\n      this._parse();\n\n      this._verifyParse();\n    }\n  }\n\n  CronTime.constraints = [[0, 59], [0, 59], [0, 23], [1, 31], [0, 11], [0, 6]];\n  CronTime.monthConstraints = [31, 29, // support leap year...not perfect\n  31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  CronTime.parseDefaults = ['0', '*', '*', '*', '*', '*'];\n  CronTime.aliases = {\n    jan: 0,\n    feb: 1,\n    mar: 2,\n    apr: 3,\n    may: 4,\n    jun: 5,\n    jul: 6,\n    aug: 7,\n    sep: 8,\n    oct: 9,\n    nov: 10,\n    dec: 11,\n    sun: 0,\n    mon: 1,\n    tue: 2,\n    wed: 3,\n    thu: 4,\n    fri: 5,\n    sat: 6\n  };\n  CronTime.prototype = {\n    _verifyParse: function () {\n      var months = Object.keys(this.month);\n      var ok = false;\n      /* if a dayOfMonth is not found in all months, we only need to fix the last\n       wrong month  to prevent infinite loop */\n\n      var lastWrongMonth = NaN;\n\n      for (var i = 0; i < months.length; i++) {\n        var m = months[i];\n        var con = CronTime.monthConstraints[parseInt(m, 10)];\n        var dsom = Object.keys(this.dayOfMonth);\n\n        for (var j = 0; j < dsom.length; j++) {\n          var dom = dsom[j];\n\n          if (dom <= con) {\n            ok = true;\n          }\n        }\n\n        if (!ok) {\n          // save the month in order to be fixed if all months fails (infinite loop)\n          lastWrongMonth = m;\n          console.warn(\"Month '\" + m + \"' is limited to '\" + con + \"' days.\");\n        }\n      } // infinite loop detected (dayOfMonth is not found in all months)\n\n\n      if (!ok) {\n        var con = CronTime.monthConstraints[parseInt(lastWrongMonth, 10)];\n        var dsom = Object.keys(this.dayOfMonth);\n\n        for (var k = 0; k < dsom.length; k++) {\n          var dom = dsom[k];\n\n          if (dom > con) {\n            delete this.dayOfMonth[dom];\n            var fixedDay = Number(dom) % con;\n            this.dayOfMonth[fixedDay] = true;\n          }\n        }\n      }\n    },\n\n    /**\n     * calculates the next send time\n     */\n    sendAt: function (i) {\n      var date = this.realDate ? this.source : moment(); // Set the timezone if given (http://momentjs.com/timezone/docs/#/using-timezones/parsing-in-zone/)\n\n      if (this.zone) {\n        date = date.tz(this.zone);\n      }\n\n      if (typeof this.utcOffset !== 'undefined') {\n        date = date.utcOffset(this.utcOffset);\n      }\n\n      if (this.realDate) {\n        const diff = moment().diff(date, 's');\n\n        if (diff > 0) {\n          throw new Error('WARNING: Date in past. Will never be fired.');\n        }\n\n        return date;\n      } // If the i argument is not given, return the next send time\n\n\n      if (isNaN(i) || i < 0) {\n        date = this._getNextDateFrom(date);\n        return date;\n      } else {\n        // Else return the next i send times\n        var dates = [];\n\n        for (; i > 0; i--) {\n          date = this._getNextDateFrom(date);\n          dates.push(moment(date));\n        }\n\n        return dates;\n      }\n    },\n\n    /**\n     * Get the number of milliseconds in the future at which to fire our callbacks.\n     */\n    getTimeout: function () {\n      return Math.max(-1, this.sendAt() - moment());\n    },\n\n    /**\n     * writes out a cron string\n     */\n    toString: function () {\n      return this.toJSON().join(' ');\n    },\n\n    /**\n     * Json representation of the parsed cron syntax.\n     */\n    toJSON: function () {\n      var self = this;\n      return timeUnits.map(function (timeName) {\n        return self._wcOrAll(timeName);\n      });\n    },\n\n    /**\n     * get next date that matches parsed cron time\n     */\n    _getNextDateFrom: function (start, zone) {\n      var date;\n      var firstDate = moment(start).valueOf();\n\n      if (zone) {\n        date = moment(start).tz(zone);\n      } else {\n        date = moment(start);\n      }\n\n      if (!this.realDate) {\n        const milliseconds = start.milliseconds && start.milliseconds() || start.getMilliseconds && start.getMilliseconds() || 0;\n\n        if (milliseconds > 0) {\n          date.milliseconds(0);\n          date.seconds(date.seconds() + 1);\n        }\n      }\n\n      if (date.toString() === 'Invalid date') {\n        throw new Error('ERROR: You specified an invalid date.');\n      } // it shouldn't take more than 5 seconds to find the next execution time\n      // being very generous with this. Throw error if it takes too long to find the next time to protect from\n      // infinite loop.\n\n\n      var timeout = Date.now() + 5000; // determine next date\n\n      while (true) {\n        var diff = date - start;\n        var prevMonth = date.month();\n        var prevDay = date.days();\n        var prevMinute = date.minutes();\n        var prevSeconds = date.seconds();\n        var origDate = new Date(date);\n\n        if (Date.now() > timeout) {\n          throw new Error(`Something went wrong. cron reached maximum iterations.\n\t\t\t\t\t\tPlease open an  issue (https://github.com/kelektiv/node-cron/issues/new) and provide the following string\n\t\t\t\t\t\tTime Zone: ${zone || '\"\"'} - Cron String: ${this} - UTC offset: ${date.format('Z')} - current Date: ${moment().toString()}`);\n        }\n\n        if (!(date.month() in this.month) && Object.keys(this.month).length !== 12) {\n          date.add(1, 'M');\n\n          if (date.month() === prevMonth) {\n            date.add(1, 'M');\n          }\n\n          date.date(1);\n          date.hours(0);\n          date.minutes(0);\n          date.seconds(0);\n          continue;\n        }\n\n        if (!(date.date() in this.dayOfMonth) && Object.keys(this.dayOfMonth).length !== 31 && !(date.day() in this.dayOfWeek && Object.keys(this.dayOfWeek).length !== 7)) {\n          date.add(1, 'd');\n\n          if (date.days() === prevDay) {\n            date.add(1, 'd');\n          }\n\n          date.hours(0);\n          date.minutes(0);\n          date.seconds(0);\n          continue;\n        }\n\n        if (!(date.day() in this.dayOfWeek) && Object.keys(this.dayOfWeek).length !== 7 && !(date.date() in this.dayOfMonth && Object.keys(this.dayOfMonth).length !== 31)) {\n          date.add(1, 'd');\n\n          if (date.days() === prevDay) {\n            date.add(1, 'd');\n          }\n\n          date.hours(0);\n          date.minutes(0);\n          date.seconds(0);\n\n          if (date <= origDate) {\n            date = this._findDST(origDate);\n          }\n\n          continue;\n        }\n\n        if (!(date.hours() in this.hour) && Object.keys(this.hour).length !== 24) {\n          origDate = moment(date);\n          var curHour = date.hours();\n          date.hours(date.hours() === 23 && diff > 86400000 ? 0 : date.hours() + 1);\n          /*\n           * Moment Date will not allow you to set the time to 2 AM if there is no 2 AM (on the day we change the clock)\n           * We will therefore jump to 3AM if time stayed at 1AM\n           */\n\n          if (curHour === date.hours()) {\n            date.hours(date.hours() + 2);\n          }\n\n          date.minutes(0);\n          date.seconds(0);\n\n          if (date <= origDate) {\n            date = this._findDST(origDate);\n          }\n\n          continue;\n        }\n\n        if (!(date.minutes() in this.minute) && Object.keys(this.minute).length !== 60) {\n          origDate = moment(date);\n          date.minutes(date.minutes() === 59 && diff > 60 * 60 * 1000 ? 0 : date.minutes() + 1);\n          date.seconds(0);\n\n          if (date <= origDate) {\n            date = this._findDST(origDate);\n          }\n\n          continue;\n        }\n\n        if (!(date.seconds() in this.second) && Object.keys(this.second).length !== 60) {\n          origDate = moment(date);\n          date.seconds(date.seconds() === 59 && diff > 60 * 1000 ? 0 : date.seconds() + 1);\n\n          if (date <= origDate) {\n            date = this._findDST(origDate);\n          }\n\n          continue;\n        }\n\n        if (date.valueOf() === firstDate) {\n          date.seconds(date.seconds() + 1);\n          continue;\n        }\n\n        break;\n      }\n\n      return date;\n    },\n\n    /**\n     * get next date that is a valid DST date\n     */\n    _findDST: function (date) {\n      var newDate = moment(date);\n\n      while (newDate <= date) {\n        // eslint seems to trigger here, it is wrong\n        newDate.add(1, 's');\n      }\n\n      return newDate;\n    },\n\n    /**\n     * wildcard, or all params in array (for to string)\n     */\n    _wcOrAll: function (type) {\n      if (this._hasAll(type)) return '*';\n      var all = [];\n\n      for (var time in this[type]) {\n        all.push(time);\n      }\n\n      return all.join(',');\n    },\n    _hasAll: function (type) {\n      var constrain = CronTime.constraints[timeUnits.indexOf(type)];\n\n      for (var i = constrain[0], n = constrain[1]; i < n; i++) {\n        if (!(i in this[type])) return false;\n      }\n\n      return true;\n    },\n    _parse: function () {\n      var aliases = CronTime.aliases;\n      var source = this.source.replace(/[a-z]{1,3}/gi, function (alias) {\n        alias = alias.toLowerCase();\n\n        if (alias in aliases) {\n          return aliases[alias];\n        }\n\n        throw new Error('Unknown alias: ' + alias);\n      });\n      var split = source.replace(/^\\s\\s*|\\s\\s*$/g, '').split(/\\s+/);\n      var cur;\n      var i = 0;\n      var len = timeUnits.length; // seconds are optional\n\n      if (split.length < timeUnits.length - 1) {\n        throw new Error('Too few fields');\n      }\n\n      if (split.length > timeUnits.length) {\n        throw new Error('Too many fields');\n      }\n\n      for (; i < timeUnits.length; i++) {\n        // If the split source string doesn't contain all digits,\n        // assume defaults for first n missing digits.\n        // This adds support for 5-digit standard cron syntax\n        cur = split[i - (len - split.length)] || CronTime.parseDefaults[i];\n\n        this._parseField(cur, timeUnits[i], CronTime.constraints[i]);\n      }\n    },\n    _parseField: function (field, type, constraints) {\n      var rangePattern = /^(\\d+)(?:-(\\d+))?(?:\\/(\\d+))?$/g;\n      var typeObj = this[type];\n      var pointer;\n      var low = constraints[0];\n      var high = constraints[1];\n      var fields = field.split(',');\n      fields.forEach(function (field) {\n        var wildcardIndex = field.indexOf('*');\n\n        if (wildcardIndex !== -1 && wildcardIndex !== 0) {\n          throw new Error('Field (' + field + ') has an invalid wildcard expression');\n        }\n      }); // * is a shortcut to [lower-upper] range\n\n      field = field.replace(/\\*/g, low + '-' + high); // commas separate information, so split based on those\n\n      var allRanges = field.split(',');\n\n      for (var i = 0; i < allRanges.length; i++) {\n        if (allRanges[i].match(rangePattern)) {\n          allRanges[i].replace(rangePattern, function ($0, lower, upper, step) {\n            lower = parseInt(lower, 10);\n            upper = parseInt(upper, 10) || undefined;\n            const wasStepDefined = !isNaN(parseInt(step, 10));\n\n            if (step === '0') {\n              throw new Error('Field (' + field + ') has a step of zero');\n            }\n\n            step = parseInt(step, 10) || 1;\n\n            if (upper && lower > upper) {\n              throw new Error('Field (' + field + ') has an invalid range');\n            }\n\n            const outOfRangeError = lower < low || upper && upper > high || !upper && lower > high;\n\n            if (outOfRangeError) {\n              throw new Error('Field (' + field + ') value is out of range');\n            } // Positive integer higher than constraints[0]\n\n\n            lower = Math.min(Math.max(low, ~~Math.abs(lower)), high); // Positive integer lower than constraints[1]\n\n            if (upper) {\n              upper = Math.min(high, ~~Math.abs(upper));\n            } else {\n              // If step is provided, the default upper range is the highest value\n              upper = wasStepDefined ? high : lower;\n            } // Count from the lower barrier to the upper\n\n\n            pointer = lower;\n\n            do {\n              typeObj[pointer] = true;\n              pointer += step;\n            } while (pointer <= upper);\n          });\n        } else {\n          throw new Error('Field (' + field + ') cannot be parsed');\n        }\n      }\n    }\n  };\n\n  function command2function(cmd) {\n    var command;\n    var args;\n\n    switch (typeof cmd) {\n      case 'string':\n        args = cmd.split(' ');\n        command = args.shift();\n        cmd = spawn.bind(undefined, command, args);\n        break;\n\n      case 'object':\n        command = cmd && cmd.command;\n\n        if (command) {\n          args = cmd.args;\n          var options = cmd.options;\n          cmd = spawn.bind(undefined, command, args, options);\n        }\n\n        break;\n    }\n\n    return cmd;\n  }\n\n  function CronJob(cronTime, onTick, onComplete, startNow, timeZone, context, runOnInit, utcOffset, unrefTimeout) {\n    var _cronTime = cronTime;\n    var argCount = 0;\n\n    for (var i = 0; i < arguments.length; i++) {\n      if (arguments[i] !== undefined) {\n        argCount++;\n      }\n    }\n\n    if (typeof cronTime !== 'string' && argCount === 1) {\n      // crontime is an object...\n      onTick = cronTime.onTick;\n      onComplete = cronTime.onComplete;\n      context = cronTime.context;\n      startNow = cronTime.start || cronTime.startNow || cronTime.startJob;\n      timeZone = cronTime.timeZone;\n      runOnInit = cronTime.runOnInit;\n      _cronTime = cronTime.cronTime;\n      utcOffset = cronTime.utcOffset;\n      unrefTimeout = cronTime.unrefTimeout;\n    }\n\n    this.context = context || this;\n    this._callbacks = [];\n    this.onComplete = command2function(onComplete);\n    this.cronTime = new CronTime(_cronTime, timeZone, utcOffset);\n    this.unrefTimeout = unrefTimeout;\n    addCallback.call(this, command2function(onTick));\n\n    if (runOnInit) {\n      this.lastExecution = new Date();\n      fireOnTick.call(this);\n    }\n\n    if (startNow) {\n      start.call(this);\n    }\n\n    return this;\n  }\n\n  var addCallback = function (callback) {\n    if (typeof callback === 'function') this._callbacks.push(callback);\n  };\n\n  CronJob.prototype.addCallback = addCallback;\n\n  CronJob.prototype.setTime = function (time) {\n    if (!(time instanceof CronTime)) throw new Error('time must be an instance of CronTime.');\n    this.stop();\n    this.cronTime = time;\n  };\n\n  CronJob.prototype.nextDate = function () {\n    return this.cronTime.sendAt();\n  };\n\n  var fireOnTick = function () {\n    for (var i = this._callbacks.length - 1; i >= 0; i--) this._callbacks[i].call(this.context, this.onComplete);\n  };\n\n  CronJob.prototype.fireOnTick = fireOnTick;\n\n  CronJob.prototype.nextDates = function (i) {\n    return this.cronTime.sendAt(i);\n  };\n\n  var start = function () {\n    if (this.running) return;\n    var MAXDELAY = 2147483647; // The maximum number of milliseconds setTimeout will wait.\n\n    var self = this;\n    var timeout = this.cronTime.getTimeout();\n    var remaining = 0;\n    var startTime;\n    if (this.cronTime.realDate) this.runOnce = true;\n\n    function _setTimeout(timeout) {\n      startTime = Date.now();\n      self._timeout = setTimeout(callbackWrapper, timeout);\n\n      if (self.unrefTimeout && typeof self._timeout.unref === 'function') {\n        self._timeout.unref();\n      }\n    } // The callback wrapper checks if it needs to sleep another period or not\n    // and does the real callback logic when it's time.\n\n\n    function callbackWrapper() {\n      var diff = startTime + timeout - Date.now();\n\n      if (diff > 0) {\n        var newTimeout = self.cronTime.getTimeout();\n\n        if (newTimeout > diff) {\n          newTimeout = diff;\n        }\n\n        remaining += newTimeout;\n      } // If there is sleep time remaining, calculate how long and go to sleep\n      // again. This processing might make us miss the deadline by a few ms\n      // times the number of sleep sessions. Given a MAXDELAY of almost a\n      // month, this should be no issue.\n\n\n      self.lastExecution = new Date();\n\n      if (remaining) {\n        if (remaining > MAXDELAY) {\n          remaining -= MAXDELAY;\n          timeout = MAXDELAY;\n        } else {\n          timeout = remaining;\n          remaining = 0;\n        }\n\n        _setTimeout(timeout);\n      } else {\n        // We have arrived at the correct point in time.\n        self.running = false; // start before calling back so the callbacks have the ability to stop the cron job\n\n        if (!self.runOnce) self.start();\n        self.fireOnTick();\n      }\n    }\n\n    if (timeout >= 0) {\n      this.running = true; // Don't try to sleep more than MAXDELAY ms at a time.\n\n      if (timeout > MAXDELAY) {\n        remaining = timeout - MAXDELAY;\n        timeout = MAXDELAY;\n      }\n\n      _setTimeout(timeout);\n    } else {\n      this.stop();\n    }\n  };\n\n  CronJob.prototype.start = start;\n\n  CronJob.prototype.lastDate = function () {\n    return this.lastExecution;\n  };\n  /**\n   * Stop the cronjob.\n   */\n\n\n  CronJob.prototype.stop = function () {\n    if (this._timeout) clearTimeout(this._timeout);\n    this.running = false;\n    if (typeof this.onComplete === 'function') this.onComplete();\n  };\n\n  exports.job = function (cronTime, onTick, onComplete, startNow, timeZone, context, runOnInit, utcOffset, unrefTimeout) {\n    return new CronJob(cronTime, onTick, onComplete, startNow, timeZone, context, runOnInit, utcOffset, unrefTimeout);\n  };\n\n  exports.time = function (cronTime, timeZone) {\n    return new CronTime(cronTime, timeZone);\n  };\n\n  exports.sendAt = function (cronTime) {\n    return exports.time(cronTime).sendAt();\n  };\n\n  exports.timeout = function (cronTime) {\n    return exports.time(cronTime).getTimeout();\n  };\n\n  exports.CronJob = CronJob;\n  exports.CronTime = CronTime;\n  return exports;\n});","map":{"version":3,"sources":["D:/REACT JS/React Upforce/daily-todo-fb-final/node_modules/cron/lib/cron.js"],"names":["root","factory","define","amd","exports","module","require","Cron","moment","childProcess","timeUnits","spawn","CronTime","source","zone","utcOffset","tz","names","indexOf","Error","that","map","timeUnit","Date","_isAMomentObject","realDate","_parse","_verifyParse","constraints","monthConstraints","parseDefaults","aliases","jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec","sun","mon","tue","wed","thu","fri","sat","prototype","months","Object","keys","month","ok","lastWrongMonth","NaN","i","length","m","con","parseInt","dsom","dayOfMonth","j","dom","console","warn","k","fixedDay","Number","sendAt","date","diff","isNaN","_getNextDateFrom","dates","push","getTimeout","Math","max","toString","toJSON","join","self","timeName","_wcOrAll","start","firstDate","valueOf","milliseconds","getMilliseconds","seconds","timeout","now","prevMonth","prevDay","days","prevMinute","minutes","prevSeconds","origDate","format","add","hours","day","dayOfWeek","_findDST","hour","curHour","minute","second","newDate","type","_hasAll","all","time","constrain","n","replace","alias","toLowerCase","split","cur","len","_parseField","field","rangePattern","typeObj","pointer","low","high","fields","forEach","wildcardIndex","allRanges","match","$0","lower","upper","step","undefined","wasStepDefined","outOfRangeError","min","abs","command2function","cmd","command","args","shift","bind","options","CronJob","cronTime","onTick","onComplete","startNow","timeZone","context","runOnInit","unrefTimeout","_cronTime","argCount","arguments","startJob","_callbacks","addCallback","call","lastExecution","fireOnTick","callback","setTime","stop","nextDate","nextDates","running","MAXDELAY","remaining","startTime","runOnce","_setTimeout","_timeout","setTimeout","callbackWrapper","unref","newTimeout","lastDate","clearTimeout","job"],"mappings":"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","sourcesContent":["(function(root, factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(['moment-timezone'], factory);\n\t} else if (typeof exports === 'object') {\n\t\tmodule.exports = factory(\n\t\t\trequire('moment-timezone'),\n\t\t\trequire('child_process')\n\t\t);\n\t} else {\n\t\troot.Cron = factory(root.moment);\n\t}\n})(this, function(moment, childProcess) {\n\tvar exports = {};\n\tvar timeUnits = [\n\t\t'second',\n\t\t'minute',\n\t\t'hour',\n\t\t'dayOfMonth',\n\t\t'month',\n\t\t'dayOfWeek'\n\t];\n\tvar spawn = childProcess && childProcess.spawn;\n\n\tfunction CronTime(source, zone, utcOffset) {\n\t\tthis.source = source;\n\n\t\tif (zone) {\n\t\t\tif (moment.tz.names().indexOf(zone) === -1) {\n\t\t\t\tthrow new Error('Invalid timezone.');\n\t\t\t}\n\n\t\t\tthis.zone = zone;\n\t\t}\n\n\t\tif (typeof utcOffset !== 'undefined') this.utcOffset = utcOffset;\n\n\t\tvar that = this;\n\t\ttimeUnits.map(function(timeUnit) {\n\t\t\tthat[timeUnit] = {};\n\t\t});\n\n\t\tif (this.source instanceof Date || this.source._isAMomentObject) {\n\t\t\tthis.source = moment(this.source);\n\t\t\tthis.realDate = true;\n\t\t} else {\n\t\t\tthis._parse();\n\t\t\tthis._verifyParse();\n\t\t}\n\t}\n\n\tCronTime.constraints = [[0, 59], [0, 59], [0, 23], [1, 31], [0, 11], [0, 6]];\n\tCronTime.monthConstraints = [\n\t\t31,\n\t\t29, // support leap year...not perfect\n\t\t31,\n\t\t30,\n\t\t31,\n\t\t30,\n\t\t31,\n\t\t31,\n\t\t30,\n\t\t31,\n\t\t30,\n\t\t31\n\t];\n\tCronTime.parseDefaults = ['0', '*', '*', '*', '*', '*'];\n\tCronTime.aliases = {\n\t\tjan: 0,\n\t\tfeb: 1,\n\t\tmar: 2,\n\t\tapr: 3,\n\t\tmay: 4,\n\t\tjun: 5,\n\t\tjul: 6,\n\t\taug: 7,\n\t\tsep: 8,\n\t\toct: 9,\n\t\tnov: 10,\n\t\tdec: 11,\n\t\tsun: 0,\n\t\tmon: 1,\n\t\ttue: 2,\n\t\twed: 3,\n\t\tthu: 4,\n\t\tfri: 5,\n\t\tsat: 6\n\t};\n\n\tCronTime.prototype = {\n\t\t_verifyParse: function() {\n\t\t\tvar months = Object.keys(this.month);\n\t\t\tvar ok = false;\n\n\t\t\t/* if a dayOfMonth is not found in all months, we only need to fix the last\n\t\t\t wrong month  to prevent infinite loop */\n\t\t\tvar lastWrongMonth = NaN;\n\t\t\tfor (var i = 0; i < months.length; i++) {\n\t\t\t\tvar m = months[i];\n\t\t\t\tvar con = CronTime.monthConstraints[parseInt(m, 10)];\n\t\t\t\tvar dsom = Object.keys(this.dayOfMonth);\n\n\t\t\t\tfor (var j = 0; j < dsom.length; j++) {\n\t\t\t\t\tvar dom = dsom[j];\n\t\t\t\t\tif (dom <= con) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!ok) {\n\t\t\t\t\t// save the month in order to be fixed if all months fails (infinite loop)\n\t\t\t\t\tlastWrongMonth = m;\n\t\t\t\t\tconsole.warn(\"Month '\" + m + \"' is limited to '\" + con + \"' days.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// infinite loop detected (dayOfMonth is not found in all months)\n\t\t\tif (!ok) {\n\t\t\t\tvar con = CronTime.monthConstraints[parseInt(lastWrongMonth, 10)];\n\t\t\t\tvar dsom = Object.keys(this.dayOfMonth);\n\t\t\t\tfor (var k = 0; k < dsom.length; k++) {\n\t\t\t\t\tvar dom = dsom[k];\n\t\t\t\t\tif (dom > con) {\n\t\t\t\t\t\tdelete this.dayOfMonth[dom];\n\t\t\t\t\t\tvar fixedDay = Number(dom) % con;\n\t\t\t\t\t\tthis.dayOfMonth[fixedDay] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * calculates the next send time\n\t\t */\n\t\tsendAt: function(i) {\n\t\t\tvar date = this.realDate ? this.source : moment();\n\t\t\t// Set the timezone if given (http://momentjs.com/timezone/docs/#/using-timezones/parsing-in-zone/)\n\t\t\tif (this.zone) {\n\t\t\t\tdate = date.tz(this.zone);\n\t\t\t}\n\n\t\t\tif (typeof this.utcOffset !== 'undefined') {\n\t\t\t\tdate = date.utcOffset(this.utcOffset);\n\t\t\t}\n\n\t\t\tif (this.realDate) {\n\t\t\t\tconst diff = moment().diff(date, 's');\n\t\t\t\tif (diff > 0) {\n\t\t\t\t\tthrow new Error('WARNING: Date in past. Will never be fired.');\n\t\t\t\t}\n\n\t\t\t\treturn date;\n\t\t\t}\n\n\t\t\t// If the i argument is not given, return the next send time\n\t\t\tif (isNaN(i) || i < 0) {\n\t\t\t\tdate = this._getNextDateFrom(date);\n\n\t\t\t\treturn date;\n\t\t\t} else {\n\t\t\t\t// Else return the next i send times\n\t\t\t\tvar dates = [];\n\t\t\t\tfor (; i > 0; i--) {\n\t\t\t\t\tdate = this._getNextDateFrom(date);\n\t\t\t\t\tdates.push(moment(date));\n\t\t\t\t}\n\n\t\t\t\treturn dates;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Get the number of milliseconds in the future at which to fire our callbacks.\n\t\t */\n\t\tgetTimeout: function() {\n\t\t\treturn Math.max(-1, this.sendAt() - moment());\n\t\t},\n\n\t\t/**\n\t\t * writes out a cron string\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.toJSON().join(' ');\n\t\t},\n\n\t\t/**\n\t\t * Json representation of the parsed cron syntax.\n\t\t */\n\t\ttoJSON: function() {\n\t\t\tvar self = this;\n\t\t\treturn timeUnits.map(function(timeName) {\n\t\t\t\treturn self._wcOrAll(timeName);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * get next date that matches parsed cron time\n\t\t */\n\t\t_getNextDateFrom: function(start, zone) {\n\t\t\tvar date;\n\t\t\tvar firstDate = moment(start).valueOf();\n\t\t\tif (zone) {\n\t\t\t\tdate = moment(start).tz(zone);\n\t\t\t} else {\n\t\t\t\tdate = moment(start);\n\t\t\t}\n\t\t\tif (!this.realDate) {\n\t\t\t\tconst milliseconds =\n\t\t\t\t\t(start.milliseconds && start.milliseconds()) ||\n\t\t\t\t\t(start.getMilliseconds && start.getMilliseconds()) ||\n\t\t\t\t\t0;\n\t\t\t\tif (milliseconds > 0) {\n\t\t\t\t\tdate.milliseconds(0);\n\t\t\t\t\tdate.seconds(date.seconds() + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (date.toString() === 'Invalid date') {\n\t\t\t\tthrow new Error('ERROR: You specified an invalid date.');\n\t\t\t}\n\n\t\t\t// it shouldn't take more than 5 seconds to find the next execution time\n\t\t\t// being very generous with this. Throw error if it takes too long to find the next time to protect from\n\t\t\t// infinite loop.\n\t\t\tvar timeout = Date.now() + 5000;\n\t\t\t// determine next date\n\t\t\twhile (true) {\n\t\t\t\tvar diff = date - start;\n\t\t\t\tvar prevMonth = date.month();\n\t\t\t\tvar prevDay = date.days();\n\t\t\t\tvar prevMinute = date.minutes();\n\t\t\t\tvar prevSeconds = date.seconds();\n\t\t\t\tvar origDate = new Date(date);\n\n\t\t\t\tif (Date.now() > timeout) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Something went wrong. cron reached maximum iterations.\n\t\t\t\t\t\tPlease open an  issue (https://github.com/kelektiv/node-cron/issues/new) and provide the following string\n\t\t\t\t\t\tTime Zone: ${zone || '\"\"'} - Cron String: ${this} - UTC offset: ${date.format(\n\t\t\t\t\t\t\t'Z'\n\t\t\t\t\t\t)} - current Date: ${moment().toString()}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t!(date.month() in this.month) &&\n\t\t\t\t\tObject.keys(this.month).length !== 12\n\t\t\t\t) {\n\t\t\t\t\tdate.add(1, 'M');\n\t\t\t\t\tif (date.month() === prevMonth) {\n\t\t\t\t\t\tdate.add(1, 'M');\n\t\t\t\t\t}\n\t\t\t\t\tdate.date(1);\n\t\t\t\t\tdate.hours(0);\n\t\t\t\t\tdate.minutes(0);\n\t\t\t\t\tdate.seconds(0);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!(date.date() in this.dayOfMonth) &&\n\t\t\t\t\tObject.keys(this.dayOfMonth).length !== 31 &&\n\t\t\t\t\t!(\n\t\t\t\t\t\tdate.day() in this.dayOfWeek &&\n\t\t\t\t\t\tObject.keys(this.dayOfWeek).length !== 7\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tdate.add(1, 'd');\n\t\t\t\t\tif (date.days() === prevDay) {\n\t\t\t\t\t\tdate.add(1, 'd');\n\t\t\t\t\t}\n\t\t\t\t\tdate.hours(0);\n\t\t\t\t\tdate.minutes(0);\n\t\t\t\t\tdate.seconds(0);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!(date.day() in this.dayOfWeek) &&\n\t\t\t\t\tObject.keys(this.dayOfWeek).length !== 7 &&\n\t\t\t\t\t!(\n\t\t\t\t\t\tdate.date() in this.dayOfMonth &&\n\t\t\t\t\t\tObject.keys(this.dayOfMonth).length !== 31\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tdate.add(1, 'd');\n\t\t\t\t\tif (date.days() === prevDay) {\n\t\t\t\t\t\tdate.add(1, 'd');\n\t\t\t\t\t}\n\t\t\t\t\tdate.hours(0);\n\t\t\t\t\tdate.minutes(0);\n\t\t\t\t\tdate.seconds(0);\n\t\t\t\t\tif (date <= origDate) {\n\t\t\t\t\t\tdate = this._findDST(origDate);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!(date.hours() in this.hour) &&\n\t\t\t\t\tObject.keys(this.hour).length !== 24\n\t\t\t\t) {\n\t\t\t\t\torigDate = moment(date);\n\t\t\t\t\tvar curHour = date.hours();\n\t\t\t\t\tdate.hours(\n\t\t\t\t\t\tdate.hours() === 23 && diff > 86400000 ? 0 : date.hours() + 1\n\t\t\t\t\t);\n\t\t\t\t\t/*\n\t\t\t\t\t * Moment Date will not allow you to set the time to 2 AM if there is no 2 AM (on the day we change the clock)\n\t\t\t\t\t * We will therefore jump to 3AM if time stayed at 1AM\n\t\t\t\t\t */\n\t\t\t\t\tif (curHour === date.hours()) {\n\t\t\t\t\t\tdate.hours(date.hours() + 2);\n\t\t\t\t\t}\n\t\t\t\t\tdate.minutes(0);\n\t\t\t\t\tdate.seconds(0);\n\t\t\t\t\tif (date <= origDate) {\n\t\t\t\t\t\tdate = this._findDST(origDate);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!(date.minutes() in this.minute) &&\n\t\t\t\t\tObject.keys(this.minute).length !== 60\n\t\t\t\t) {\n\t\t\t\t\torigDate = moment(date);\n\t\t\t\t\tdate.minutes(\n\t\t\t\t\t\tdate.minutes() === 59 && diff > 60 * 60 * 1000\n\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t: date.minutes() + 1\n\t\t\t\t\t);\n\t\t\t\t\tdate.seconds(0);\n\t\t\t\t\tif (date <= origDate) {\n\t\t\t\t\t\tdate = this._findDST(origDate);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!(date.seconds() in this.second) &&\n\t\t\t\t\tObject.keys(this.second).length !== 60\n\t\t\t\t) {\n\t\t\t\t\torigDate = moment(date);\n\t\t\t\t\tdate.seconds(\n\t\t\t\t\t\tdate.seconds() === 59 && diff > 60 * 1000 ? 0 : date.seconds() + 1\n\t\t\t\t\t);\n\t\t\t\t\tif (date <= origDate) {\n\t\t\t\t\t\tdate = this._findDST(origDate);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (date.valueOf() === firstDate) {\n\t\t\t\t\tdate.seconds(date.seconds() + 1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn date;\n\t\t},\n\n\t\t/**\n\t\t * get next date that is a valid DST date\n\t\t */\n\t\t_findDST: function(date) {\n\t\t\tvar newDate = moment(date);\n\t\t\twhile (newDate <= date) {\n\t\t\t\t// eslint seems to trigger here, it is wrong\n\t\t\t\tnewDate.add(1, 's');\n\t\t\t}\n\n\t\t\treturn newDate;\n\t\t},\n\n\t\t/**\n\t\t * wildcard, or all params in array (for to string)\n\t\t */\n\t\t_wcOrAll: function(type) {\n\t\t\tif (this._hasAll(type)) return '*';\n\n\t\t\tvar all = [];\n\t\t\tfor (var time in this[type]) {\n\t\t\t\tall.push(time);\n\t\t\t}\n\n\t\t\treturn all.join(',');\n\t\t},\n\n\t\t_hasAll: function(type) {\n\t\t\tvar constrain = CronTime.constraints[timeUnits.indexOf(type)];\n\n\t\t\tfor (var i = constrain[0], n = constrain[1]; i < n; i++) {\n\t\t\t\tif (!(i in this[type])) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\t_parse: function() {\n\t\t\tvar aliases = CronTime.aliases;\n\t\t\tvar source = this.source.replace(/[a-z]{1,3}/gi, function(alias) {\n\t\t\t\talias = alias.toLowerCase();\n\n\t\t\t\tif (alias in aliases) {\n\t\t\t\t\treturn aliases[alias];\n\t\t\t\t}\n\n\t\t\t\tthrow new Error('Unknown alias: ' + alias);\n\t\t\t});\n\t\t\tvar split = source.replace(/^\\s\\s*|\\s\\s*$/g, '').split(/\\s+/);\n\t\t\tvar cur;\n\t\t\tvar i = 0;\n\t\t\tvar len = timeUnits.length;\n\n\t\t\t// seconds are optional\n\t\t\tif (split.length < timeUnits.length - 1) {\n\t\t\t\tthrow new Error('Too few fields');\n\t\t\t}\n\t\t\tif (split.length > timeUnits.length) {\n\t\t\t\tthrow new Error('Too many fields');\n\t\t\t}\n\n\t\t\tfor (; i < timeUnits.length; i++) {\n\t\t\t\t// If the split source string doesn't contain all digits,\n\t\t\t\t// assume defaults for first n missing digits.\n\t\t\t\t// This adds support for 5-digit standard cron syntax\n\t\t\t\tcur = split[i - (len - split.length)] || CronTime.parseDefaults[i];\n\t\t\t\tthis._parseField(cur, timeUnits[i], CronTime.constraints[i]);\n\t\t\t}\n\t\t},\n\n\t\t_parseField: function(field, type, constraints) {\n\t\t\tvar rangePattern = /^(\\d+)(?:-(\\d+))?(?:\\/(\\d+))?$/g;\n\t\t\tvar typeObj = this[type];\n\t\t\tvar pointer;\n\t\t\tvar low = constraints[0];\n\t\t\tvar high = constraints[1];\n\n\t\t\tvar fields = field.split(',');\n\t\t\tfields.forEach(function(field) {\n\t\t\t\tvar wildcardIndex = field.indexOf('*');\n\t\t\t\tif (wildcardIndex !== -1 && wildcardIndex !== 0) {\n\t\t\t\t\tthrow new Error('Field (' + field + ') has an invalid wildcard expression');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// * is a shortcut to [lower-upper] range\n\t\t\tfield = field.replace(/\\*/g, low + '-' + high);\n\n\t\t\t// commas separate information, so split based on those\n\t\t\tvar allRanges = field.split(',');\n\n\t\t\tfor (var i = 0; i < allRanges.length; i++) {\n\t\t\t\tif (allRanges[i].match(rangePattern)) {\n\t\t\t\t\tallRanges[i].replace(rangePattern, function($0, lower, upper, step) {\n\t\t\t\t\t\tlower = parseInt(lower, 10);\n\t\t\t\t\t\tupper = parseInt(upper, 10) || undefined;\n\n\t\t\t\t\t\tconst wasStepDefined = !isNaN(parseInt(step, 10));\n\t\t\t\t\t\tif (step === '0') {\n\t\t\t\t\t\t\tthrow new Error('Field (' + field + ') has a step of zero');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstep = parseInt(step, 10) || 1;\n\n\t\t\t\t\t\tif (upper && lower > upper) {\n\t\t\t\t\t\t\tthrow new Error('Field (' + field + ') has an invalid range');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst outOfRangeError =\n\t\t\t\t\t\t\tlower < low ||\n\t\t\t\t\t\t\t(upper && upper > high) ||\n\t\t\t\t\t\t\t(!upper && lower > high);\n\n\t\t\t\t\t\tif (outOfRangeError) {\n\t\t\t\t\t\t\tthrow new Error('Field (' + field + ') value is out of range');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Positive integer higher than constraints[0]\n\t\t\t\t\t\tlower = Math.min(Math.max(low, ~~Math.abs(lower)), high);\n\n\t\t\t\t\t\t// Positive integer lower than constraints[1]\n\t\t\t\t\t\tif (upper) {\n\t\t\t\t\t\t\tupper = Math.min(high, ~~Math.abs(upper));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If step is provided, the default upper range is the highest value\n\t\t\t\t\t\t\tupper = wasStepDefined ? high : lower;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Count from the lower barrier to the upper\n\t\t\t\t\t\tpointer = lower;\n\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ttypeObj[pointer] = true;\n\t\t\t\t\t\t\tpointer += step;\n\t\t\t\t\t\t} while (pointer <= upper);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Field (' + field + ') cannot be parsed');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction command2function(cmd) {\n\t\tvar command;\n\t\tvar args;\n\n\t\tswitch (typeof cmd) {\n\t\t\tcase 'string':\n\t\t\t\targs = cmd.split(' ');\n\t\t\t\tcommand = args.shift();\n\n\t\t\t\tcmd = spawn.bind(undefined, command, args);\n\t\t\t\tbreak;\n\n\t\t\tcase 'object':\n\t\t\t\tcommand = cmd && cmd.command;\n\t\t\t\tif (command) {\n\t\t\t\t\targs = cmd.args;\n\t\t\t\t\tvar options = cmd.options;\n\n\t\t\t\t\tcmd = spawn.bind(undefined, command, args, options);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn cmd;\n\t}\n\n\tfunction CronJob(\n\t\tcronTime,\n\t\tonTick,\n\t\tonComplete,\n\t\tstartNow,\n\t\ttimeZone,\n\t\tcontext,\n\t\trunOnInit,\n\t\tutcOffset,\n\t\tunrefTimeout\n\t) {\n\t\tvar _cronTime = cronTime;\n\t\tvar argCount = 0;\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tif (arguments[i] !== undefined) {\n\t\t\t\targCount++;\n\t\t\t}\n\t\t}\n\t\tif (typeof cronTime !== 'string' && argCount === 1) {\n\t\t\t// crontime is an object...\n\t\t\tonTick = cronTime.onTick;\n\t\t\tonComplete = cronTime.onComplete;\n\t\t\tcontext = cronTime.context;\n\t\t\tstartNow = cronTime.start || cronTime.startNow || cronTime.startJob;\n\t\t\ttimeZone = cronTime.timeZone;\n\t\t\trunOnInit = cronTime.runOnInit;\n\t\t\t_cronTime = cronTime.cronTime;\n\t\t\tutcOffset = cronTime.utcOffset;\n\t\t\tunrefTimeout = cronTime.unrefTimeout;\n\t\t}\n\n\t\tthis.context = context || this;\n\t\tthis._callbacks = [];\n\t\tthis.onComplete = command2function(onComplete);\n\t\tthis.cronTime = new CronTime(_cronTime, timeZone, utcOffset);\n\t\tthis.unrefTimeout = unrefTimeout;\n\n\t\taddCallback.call(this, command2function(onTick));\n\n\t\tif (runOnInit) {\n\t\t\tthis.lastExecution = new Date();\n\t\t\tfireOnTick.call(this);\n\t\t}\n\n\t\tif (startNow) {\n\t\t\tstart.call(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tvar addCallback = function(callback) {\n\t\tif (typeof callback === 'function') this._callbacks.push(callback);\n\t};\n\tCronJob.prototype.addCallback = addCallback;\n\n\tCronJob.prototype.setTime = function(time) {\n\t\tif (!(time instanceof CronTime))\n\t\t\tthrow new Error('time must be an instance of CronTime.');\n\t\tthis.stop();\n\t\tthis.cronTime = time;\n\t};\n\n\tCronJob.prototype.nextDate = function() {\n\t\treturn this.cronTime.sendAt();\n\t};\n\n\tvar fireOnTick = function() {\n\t\tfor (var i = this._callbacks.length - 1; i >= 0; i--)\n\t\t\tthis._callbacks[i].call(this.context, this.onComplete);\n\t};\n\tCronJob.prototype.fireOnTick = fireOnTick;\n\n\tCronJob.prototype.nextDates = function(i) {\n\t\treturn this.cronTime.sendAt(i);\n\t};\n\n\tvar start = function() {\n\t\tif (this.running) return;\n\n\t\tvar MAXDELAY = 2147483647; // The maximum number of milliseconds setTimeout will wait.\n\t\tvar self = this;\n\t\tvar timeout = this.cronTime.getTimeout();\n\t\tvar remaining = 0;\n\t\tvar startTime;\n\n\t\tif (this.cronTime.realDate) this.runOnce = true;\n\n\t\tfunction _setTimeout(timeout) {\n\t\t\tstartTime = Date.now();\n\t\t\tself._timeout = setTimeout(callbackWrapper, timeout);\n\t\t\tif (self.unrefTimeout && typeof self._timeout.unref === 'function') {\n\t\t\t\tself._timeout.unref();\n\t\t\t}\n\t\t}\n\n\t\t// The callback wrapper checks if it needs to sleep another period or not\n\t\t// and does the real callback logic when it's time.\n\n\t\tfunction callbackWrapper() {\n\t\t\tvar diff = startTime + timeout - Date.now();\n\n\t\t\tif (diff > 0) {\n\t\t\t\tvar newTimeout = self.cronTime.getTimeout();\n\n\t\t\t\tif (newTimeout > diff) {\n\t\t\t\t\tnewTimeout = diff;\n\t\t\t\t}\n\n\t\t\t\tremaining += newTimeout;\n\t\t\t}\n\n\t\t\t// If there is sleep time remaining, calculate how long and go to sleep\n\t\t\t// again. This processing might make us miss the deadline by a few ms\n\t\t\t// times the number of sleep sessions. Given a MAXDELAY of almost a\n\t\t\t// month, this should be no issue.\n\n\t\t\tself.lastExecution = new Date();\n\t\t\tif (remaining) {\n\t\t\t\tif (remaining > MAXDELAY) {\n\t\t\t\t\tremaining -= MAXDELAY;\n\t\t\t\t\ttimeout = MAXDELAY;\n\t\t\t\t} else {\n\t\t\t\t\ttimeout = remaining;\n\t\t\t\t\tremaining = 0;\n\t\t\t\t}\n\n\t\t\t\t_setTimeout(timeout);\n\t\t\t} else {\n\t\t\t\t// We have arrived at the correct point in time.\n\n\t\t\t\tself.running = false;\n\n\t\t\t\t// start before calling back so the callbacks have the ability to stop the cron job\n\t\t\t\tif (!self.runOnce) self.start();\n\n\t\t\t\tself.fireOnTick();\n\t\t\t}\n\t\t}\n\n\t\tif (timeout >= 0) {\n\t\t\tthis.running = true;\n\n\t\t\t// Don't try to sleep more than MAXDELAY ms at a time.\n\n\t\t\tif (timeout > MAXDELAY) {\n\t\t\t\tremaining = timeout - MAXDELAY;\n\t\t\t\ttimeout = MAXDELAY;\n\t\t\t}\n\n\t\t\t_setTimeout(timeout);\n\t\t} else {\n\t\t\tthis.stop();\n\t\t}\n\t};\n\n\tCronJob.prototype.start = start;\n\n\tCronJob.prototype.lastDate = function() {\n\t\treturn this.lastExecution;\n\t};\n\n\t/**\n\t * Stop the cronjob.\n\t */\n\tCronJob.prototype.stop = function() {\n\t\tif (this._timeout) clearTimeout(this._timeout);\n\t\tthis.running = false;\n\t\tif (typeof this.onComplete === 'function') this.onComplete();\n\t};\n\n\texports.job = function(\n\t\tcronTime,\n\t\tonTick,\n\t\tonComplete,\n\t\tstartNow,\n\t\ttimeZone,\n\t\tcontext,\n\t\trunOnInit,\n\t\tutcOffset,\n\t\tunrefTimeout\n\t) {\n\t\treturn new CronJob(\n\t\t\tcronTime,\n\t\t\tonTick,\n\t\t\tonComplete,\n\t\t\tstartNow,\n\t\t\ttimeZone,\n\t\t\tcontext,\n\t\t\trunOnInit,\n\t\t\tutcOffset,\n\t\t\tunrefTimeout\n\t\t);\n\t};\n\n\texports.time = function(cronTime, timeZone) {\n\t\treturn new CronTime(cronTime, timeZone);\n\t};\n\n\texports.sendAt = function(cronTime) {\n\t\treturn exports.time(cronTime).sendAt();\n\t};\n\n\texports.timeout = function(cronTime) {\n\t\treturn exports.time(cronTime).getTimeout();\n\t};\n\n\texports.CronJob = CronJob;\n\texports.CronTime = CronTime;\n\n\treturn exports;\n});\n"]},"metadata":{},"sourceType":"script"}